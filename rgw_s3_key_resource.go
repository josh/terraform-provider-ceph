package main

import (
	"context"
	"fmt"
	"strings"
	"sync"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	resourceSchema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

var (
	_ resource.Resource                = &RGWS3KeyResource{}
	_ resource.ResourceWithImportState = &RGWS3KeyResource{}

	userLocks sync.Map
)

func newRGWS3KeyResource() resource.Resource {
	return &RGWS3KeyResource{}
}

type RGWS3KeyResource struct {
	client *CephAPIClient
}

func (r *RGWS3KeyResource) getUserLock(uid string) *sync.RWMutex {
	actual, _ := userLocks.LoadOrStore(uid, &sync.RWMutex{})
	return actual.(*sync.RWMutex)
}

type RGWS3KeyResourceModel struct {
	UserID     types.String `tfsdk:"user_id"`
	AccessKey  types.String `tfsdk:"access_key"`
	SecretKey  types.String `tfsdk:"secret_key"`
	User       types.String `tfsdk:"user"`
	Active     types.Bool   `tfsdk:"active"`
	CreateDate types.String `tfsdk:"create_date"`
}

func (r *RGWS3KeyResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_rgw_s3_key"
}

func (r *RGWS3KeyResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = resourceSchema.Schema{
		MarkdownDescription: "This resource allows you to manage a Ceph RGW S3 access key. Similar to AWS IAM access keys, these keys provide programmatic access to the RGW S3 API.",
		Attributes: map[string]resourceSchema.Attribute{
			"user_id": resourceSchema.StringAttribute{
				MarkdownDescription: "The user or subuser ID that owns this S3 key (format: 'user_id' for users or 'user_id:subuser' for subusers)",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"access_key": resourceSchema.StringAttribute{
				MarkdownDescription: "The S3 access key ID. If not specified, will be auto-generated by Ceph.",
				Optional:            true,
				Computed:            true,
				Sensitive:           true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"secret_key": resourceSchema.StringAttribute{
				MarkdownDescription: "The S3 secret key. If not specified, will be auto-generated by Ceph.",
				Optional:            true,
				Computed:            true,
				Sensitive:           true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"user": resourceSchema.StringAttribute{
				MarkdownDescription: "The user identifier returned by the API (matches user_id for regular users)",
				Computed:            true,
			},
			"active": resourceSchema.BoolAttribute{
				MarkdownDescription: "Whether the key is active",
				Computed:            true,
			},
			"create_date": resourceSchema.StringAttribute{
				MarkdownDescription: "The creation date of the key",
				Computed:            true,
			},
		},
	}
}

func (r *RGWS3KeyResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*CephAPIClient)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *CephAPIClient, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}

	r.client = client
}

func (r *RGWS3KeyResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data RGWS3KeyResourceModel

	resp.Diagnostics.Append(req.Plan.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	userID := data.UserID.ValueString()
	parts := strings.SplitN(userID, ":", 2)
	parentUID := parts[0]

	mu := r.getUserLock(parentUID)
	mu.Lock()
	defer mu.Unlock()

	var subuser *string
	if len(parts) == 2 {
		subuser = &userID
	}

	var accessKeyPtr *string
	var secretKeyPtr *string
	generateKey := true

	if !data.AccessKey.IsNull() && !data.AccessKey.IsUnknown() {
		accessKey := data.AccessKey.ValueString()
		accessKeyPtr = &accessKey
		generateKey = false
	}

	if !data.SecretKey.IsNull() && !data.SecretKey.IsUnknown() {
		secretKey := data.SecretKey.ValueString()
		secretKeyPtr = &secretKey
		generateKey = false
	}

	existingKeys := make(map[string]bool)
	if accessKeyPtr == nil {
		user, err := r.client.RGWGetUser(ctx, parentUID)
		if err == nil {
			for _, key := range user.Keys {
				if key.User == userID {
					existingKeys[key.AccessKey] = true
				}
			}
		}
	}

	keys, err := r.client.RGWCreateS3Key(ctx, parentUID, subuser, accessKeyPtr, secretKeyPtr, &generateKey)
	if err != nil {
		resp.Diagnostics.AddError(
			"API Request Error",
			fmt.Sprintf("Unable to create RGW S3 key: %s", err),
		)
		return
	}

	if len(keys) == 0 {
		resp.Diagnostics.AddError(
			"Key Creation Error",
			"No keys returned in API response",
		)
		return
	}

	var createdKey *CephAPIRGWS3Key
	if accessKeyPtr != nil {
		for i := range keys {
			if keys[i].AccessKey == *accessKeyPtr && keys[i].User == userID {
				createdKey = &keys[i]
				break
			}
		}
		if createdKey == nil {
			resp.Diagnostics.AddError(
				"Key Creation Error",
				fmt.Sprintf("Created key %s was not found in API response for user %s", *accessKeyPtr, userID),
			)
			return
		}
	} else {
		for i := range keys {
			if keys[i].User == userID && !existingKeys[keys[i].AccessKey] {
				createdKey = &keys[i]
				break
			}
		}
		if createdKey == nil {
			resp.Diagnostics.AddError(
				"Key Creation Error",
				fmt.Sprintf("Could not identify newly created key in API response for user %s", userID),
			)
			return
		}
	}

	updateModelFromAPIKey(&data, createdKey)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *RGWS3KeyResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data RGWS3KeyResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	userID := data.UserID.ValueString()
	accessKey := data.AccessKey.ValueString()

	parts := strings.SplitN(userID, ":", 2)
	parentUID := parts[0]

	mu := r.getUserLock(parentUID)
	mu.RLock()
	defer mu.RUnlock()

	user, err := r.client.RGWGetUser(ctx, parentUID)
	if err != nil {
		resp.Diagnostics.AddError(
			"API Request Error",
			fmt.Sprintf("Unable to read RGW user: %s", err),
		)
		return
	}

	var foundKey *CephAPIRGWS3Key
	for i := range user.Keys {
		if user.Keys[i].User == userID && user.Keys[i].AccessKey == accessKey {
			foundKey = &user.Keys[i]
			break
		}
	}

	if foundKey == nil {
		resp.State.RemoveResource(ctx)
		return
	}

	updateModelFromAPIKey(&data, foundKey)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *RGWS3KeyResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	resp.Diagnostics.AddError(
		"Update Not Supported",
		"RGW S3 keys cannot be updated in place. To change a key, delete and recreate it.",
	)
}

func (r *RGWS3KeyResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data RGWS3KeyResourceModel

	resp.Diagnostics.Append(req.State.Get(ctx, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	userID := data.UserID.ValueString()
	accessKey := data.AccessKey.ValueString()

	parts := strings.SplitN(userID, ":", 2)
	parentUID := parts[0]

	mu := r.getUserLock(parentUID)
	mu.Lock()
	defer mu.Unlock()

	user, err := r.client.RGWGetUser(ctx, parentUID)
	if err != nil {
		if strings.Contains(err.Error(), "status 404") || strings.Contains(err.Error(), "status 500") {
			return
		}
		resp.Diagnostics.AddWarning(
			"API Request Warning",
			fmt.Sprintf("Unable to verify key existence before deletion: %s. Proceeding with deletion attempt.", err),
		)
	} else {
		var keyExists bool
		for i := range user.Keys {
			if user.Keys[i].User == userID && user.Keys[i].AccessKey == accessKey {
				keyExists = true
				break
			}
		}

		if !keyExists {
			return
		}
	}

	var subuser *string
	if len(parts) == 2 {
		subuser = &userID
	}

	err = r.client.RGWDeleteS3Key(ctx, parentUID, accessKey, subuser)
	if err != nil {
		resp.Diagnostics.AddError(
			"API Request Error",
			fmt.Sprintf("Unable to delete RGW S3 key: %s", err),
		)
		return
	}
}

func (r *RGWS3KeyResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	parts := strings.Split(req.ID, ":")

	var userID, accessKey string

	if len(parts) == 2 {
		userID = parts[0]
		accessKey = parts[1]
	} else if len(parts) == 3 {
		userID = parts[0] + ":" + parts[1]
		accessKey = parts[2]
	} else {
		resp.Diagnostics.AddError(
			"Invalid Import ID",
			fmt.Sprintf("Expected import ID in format 'user_id:access_key' or 'user_id:subuser:access_key', got: %s", req.ID),
		)
		return
	}

	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("user_id"), userID)...)
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("access_key"), accessKey)...)
}

func updateModelFromAPIKey(data *RGWS3KeyResourceModel, key *CephAPIRGWS3Key) {
	data.AccessKey = types.StringValue(key.AccessKey)
	data.SecretKey = types.StringValue(key.SecretKey)
	data.User = types.StringValue(key.User)
	data.Active = types.BoolValue(key.Active)
	if key.CreateDate != "" {
		data.CreateDate = types.StringValue(key.CreateDate)
	} else {
		data.CreateDate = types.StringNull()
	}
}
